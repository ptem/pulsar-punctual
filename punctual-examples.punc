-- Punctual Example File
-- Use Shift+Enter to evaluate each line
-- Use Ctrl+Enter to evaluate blocks (paragraphs)
-- Use Ctrl+Alt+Enter to evaluate all code

-- Default Punctual code from https://dktr0.github.io/Punctual/
x1 << osc $ 0.11*[1,2]; y1 << osc $ 0.08/[3,4];
x2 << osc $ 0.06/[5,6]; y2 << osc $ 0.04*[7,8];
ls << mono $ iline [x1,y1] [x2,y2] 0.002;
col << hsvrgb [osc 0.11,0.5 ~~ 1 $ osc 0.12, 1];
mask << prox 0 ** 8;
a << fit 1 $ ls * col * mask;
gate 0.1 (maxp a (fb * 0.98)) >> add <> 5

-- Clear output (hush)
0 >> add

-- Bouncing balls (from savamala docs)
fit 1 $ (circle [-0.6, osc 0.25] 0.1 * [1,0,0] +:
circle [-0.2, tri 0.25] 0.1 * [0,0,1] +:
circle [0.2, saw 0.25] 0.1 * [1,0,1] +:
circle [0.6, osc 0.5] 0.1 * [0,1,0]) >> add;





-- AUDIO REACTIVITY EXAMPLES
-- Note: The old orbit-based amp/onset approach doesn't work because
-- Punctual's DSL doesn't support external JavaScript functions.
-- Use the audio input examples below instead!

-- AUDIO-REACTIVE VISUALS (using Punctual's built-in audio analysis)
-- These examples use audio INPUT analysis, not OSC metadata
--
-- SETUP REQUIRED:
-- 1. Install virtual audio cable (e.g., VB-Cable, Voicemeeter, or Loopback on Mac)
-- 2. Route SuperCollider/Tidal output to the virtual cable
-- 3. Set browser's audio input to the virtual cable
-- 4. Grant microphone permission when prompted
--
-- Once audio is routed, these examples will react to frequency content:

-- Simple: Low/Mid/High frequency bands as RGB colors
[ilo, imid, ihi] >> add

-- Pulsating circle that grows with low frequencies (bass/kicks)
circle [0, 0] (0.2 + ilo * 0.5) * [ilo, imid, ihi] >> add

-- Three circles: bass (red), mids (green), highs (yellow/white)
bass << circle [-0.5, 0] (0.15 + ilo * 0.3) * [1, 0, 0] * (ilo * 2);
mids << circle [0, 0] (0.15 + imid * 0.3) * [0, 1, 0] * (imid * 2);
highs << circle [0.5, 0] (0.15 + ihi * 0.3) * [1, 1, 0] * (ihi * 3);
(bass + mids + highs) >> add

-- With feedback trails for ghosting effect
bass << circle [-0.5, 0] (0.15 + ilo * 0.3) * [1, 0, 0] * (ilo * 2);
mids << circle [0, 0] (0.15 + imid * 0.3) * [0, 1, 0] * (imid * 2);
highs << circle [0.5, 0] (0.15 + ihi * 0.3) * [1, 1, 0] * (ihi * 3);
(bass + mids + highs + fb * 0.95) >> add

-- Frequency spectrum visualization using FFT
-- Scans across frequency range and displays amplitude
freq << fx * 2 - 1;
amplitude << ifft freq;
col << [amplitude, amplitude * 0.5, 0];
rect [fx * 2 - 1, amplitude - 1] [0.01, amplitude * 2] * col >> add

-- Advanced: Frequency-reactive grid with color and motion
freq << fx * 2 - 1;
amp << ifft freq;
y << fy + amp * 0.3;
grid << tile [20, 10] $ circle [0, y] (0.05 * amp);
hue << amp * 0.5 + osc 0.1;
col << hsvrgb [hue, 0.8, 1];
grid * col >> add


rt << [sin $ 0.5*pi*etime, etime];
c << circle (0.8*rtxy rt) 0.08;
pattern << fit 1 $ setfxy [fr,ft*5] $ tilexy [2*pi,pi] c;
pattern * [0.3,0.3,1] >> add;
move [-0.003,0] fb >> add;


-- ===================================
-- AUDIO OUTPUT EXAMPLES
-- ===================================
-- Use >> audio to send signals to speakers
-- (Same oscillators/filters work for audio and visuals)

-- Basic tones
osc 440 >> audio;

-- Stereo output (2 channels)
osc [440, 554] >> audio

-- Quad output (4 channels spread across stereo)
osc [220, 330, 440, 550] >> audio

-- Triangle, sawtooth, square waves
tri 220 >> audio
saw 220 >> audio
sqr 220 >> audio

-- MIDI note conversion
osc (midicps 60) >> audio
osc (midicps [60, 64, 67]) >> audio

-- Amplitude control with decibels
osc 440 * dbamp (-6) >> audio
osc 440 * dbamp (-12) >> audio

-- Low-frequency oscillators for modulation
osc 440 * lftri 5 >> audio
osc (440 * (1 + 0.1 * lfsaw 6)) >> audio

-- Filters
lpf 500 1 (saw 110) >> audio
hpf 500 1 (saw 110) >> audio
bpf 1000 1 (saw 110) >> audio

-- Dynamic filter sweep
lpf (200 ~~ 2000 $ lftri 0.5) 1 (saw 110) >> audio

-- Combining audio and visuals
osc 1120 >> audio; circle [0,0] (0.3 + ilo * 0.2) * [ilo, imid, ihi] >> add


-- Multiple audio outputs (layered)
saw 110 * dbamp (-6) >> audio; tri 220 * dbamp (-12) >> audio




[1,0,0] >> add; -- a very red screen
[0,1,0] >> add; -- a very green screen
[0,0,1] >> add; -- a very blue screen
[osc 0.2,0,0] >> add; -- a pulsating red screen (modulated by a sine wave)
[unipolar $ osc 0.2, 0, 0] >> add; -- using all of the sine wave's range for the colour
[unipolar fx,0,0] >> add; -- getting redder as we go from left to right
[0,unipolar fy,0] >> add; -- getting greener as we go from top to bottom


saw (midicps $ 24 +- 0.03 $ osc 1) >> audio; -- go between 3% below MIDI note 24 and 3% above, driven by a 1 Hz sine wave
lpf (100 ~~ 1000 $ osc 1) (saw $ midicps 24)  >> audio; -- filter frequency from 100 to 1000, driven by a 1 Hz sine wave
saw (midicps $ 24 +- 0.03 $ osc 1 * sqr 2) >> audio; -- using a more complex "driver" for the modulation




































fit 1 $ circle (-0.25) (0.2 - 0.2*saw (cps*4)) >> add;
pos << [time%1, beat%1, (beat*4)%1];
hline pos 0.01 >> add;


0 >> add;




synth mn = (sqr $ midicps mn) * (dbamp (-10));
synth $ seq [50, 0, 30, 0] >> audio;
rt << [sin $ 0.5*pi*((2*beat)%4), ((2*beat)%4)];
c << circle (0.2*rtxy rt) 0.2;
pattern << fit 1 $ setfxy [0.1*fr*((8*beat)%16),ft*((8*beat)%4)] $ tilexy [2*pi,pi] c;
pattern * [2*(beat%2),0,(beat%1)] >> add;
move [-0.5*((2*beat)%16),0] fb >> add;
